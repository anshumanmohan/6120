My implementation of TDCE is straightforward. As suggested, I define "one pass" variants of the two strategies, compose those, and then iterate the composition to convergence. I do not support jumps and branches. Instead of throwing an error, I check for jumps and branches and, on finding any, correctly do nothing. 

I tested my implementation by running it on the suite of reference examples. There were a few programs that I did a "better" or comparable job on (modulo alpha renaming) so I used turnt's --save utility to clobber the expected values.

My implementation of LVN is organized in a similar way; I compose LVN with TDCE and iterate the composed method until convergence. I used a DataFrame for my table, which was a bit clunky and may have been a mistake. Anyway I got through it with a few getters and setters. As an extension to the basic algorithm, I expose the semantics of arithmetic, logic, identity, copying, and const, and realize some profit. 

Again, I tested my implementation against the suite of reference examples for TDCE and LVN. Where appropriate, I clobbered the expected .out values with my own. Introducing constant-folding and exposing the semantics of arithmetic collapses many of the previous examples into two-liners. 

A few problems I ran into:
- Introducing constant-folding and exposing the compiler to math rules raised the interesting question of what one should do when tasked with illegal math, e.g. division by zero. I currently deal with instructions that divide by zero by leaving them alone.
- Composing and iterating compiler passes means that it's sometimes a bit tricky to see how different passes are working independently. Constant-folding in particular "magics away" lines of code that would have otherwise been evidence of other correctly-implemented optimizations. I believe my implementations to be correct because I worked on constant-folding towards the end, and so I had already tested other features against my .out files. However, this is clearly not a good long-term solution. In a similar vein, a few examples such as logical-operators.bril and fold-comparisons.bril are handled nicely by LVN, but then cleaned up aggressively by TDCE. I made sure to get them right by turning TDCE off temporarily. However, the .out files I've submitted look rather sparse. I can think of a grungy solution involving many sets of runner files, test directories, and turnt.toml files, but I suspect there's a better way.